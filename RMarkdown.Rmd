---
output:
  pdf_document: default
  html_document: default
---
```{r}

install.packages("dplyr")
install.packages("readr")
install.packages("fs")
install.packages("data.table")
install.packages("R.utils")
install.packages("stringr")
tinytex::install_tinytex()()
install.packages("ggplot2")
install.packages("forcats")
install.packages("tidyr")
library(dplyr)
library(readr)
library(fs)
library(data.table)
library(R.utils)
library(stringr)

```

Data Pulling Script
```{r}
# Set up base URL and file list
base_url <- "https://datasets.imdbws.com/"   # Base URL for IMDb datasets
files <- c("title.basics.tsv.gz", "title.ratings.tsv.gz") # The two datasets we want to download
# Set up output directory 
out_dir <- "data/imdb" # Folder to store the downloaded files
dir_create(out_dir) # Create the directory if it doesn't already exist
# Download IMDb files if not already present locally ---
for (f in files) {
  dest <- file.path(out_dir, f)  # Full local path for each file
  if (!file_exists(dest)) {  # Only download if file is missing
    download.file(paste0(base_url, f), # Construct the full URL
    destfile = dest,  # Where to save it locally
    mode = "wb", # Write in binary mode (important for .gz files)
    quiet = TRUE) # Suppress download messages

  }
}
# Load IMDb datasets into R 
# fread() from data.table is used for fast reading of large .tsv files

basics   <- fread(file.path(out_dir, "title.basics.tsv.gz"),
                  sep = "\t", na.strings = "\\N", quote = "")
ratings  <- fread(file.path(out_dir, "title.ratings.tsv.gz"),
                  sep = "\t", na.strings = "\\N", quote = "")
```
```{r}
#Quick exploration of the datasets
summary(ratings)
summary(basics)
str(ratings)
str(basics)
# Convert columns stored as character to numeric for easier analysis
basics$startYear <- as.numeric(basics$startYear)
basics$runtimeMinutes <- as.numeric(basics$runtimeMinutes)
```


```{r}
# Select only the relevant columns from basics dataset
basics <- basics %>% select(tconst, # Unique title identifier (key for merging)
                            titleType,  # Type of the title (movie, short, tvSeries, etc.)
                            primaryTitle, # Main title
                            startYear,  # Release year
                            runtimeMinutes, # Duration in minutes
                            genres # List of genres
)%>% filter(titleType =="movie", # Keep only feature films
                             startYear >= 2011, startYear <= 2020) #, # Released from 2011 onwards up to 2020
                             #!is.na(runtimeMinutes)) # Exclude entries with missing runtime
```
Checking Missing Values
```{r}
#Count how many NAs there are
sum(is.na(basics$runtimeMinutes))
mean(is.na(basics$runtimeMinutes))  # proportion of missing values

#Compare distributions (movies with vs. without runtimeMinutes)
basics$runtime_missing <- is.na(basics$runtimeMinutes)
table(basics$runtime_missing)

#Check if NAs are more common for certain years, title types, or genres:
library(ggplot2)
library(forcats)
library(tidyr)


#Check if NAs are related to popularity (ratings dataset)
# Step 1: Split multi-genre strings into separate rows
basics_long <- basics %>%
  separate_rows(genres, sep = ",") %>%
  mutate(runtime_missing = is.na(runtimeMinutes))

# Step 2: Collapse to top 10 genres (rest -> "Other")
basics_long <- basics_long %>%
  mutate(genres = fct_lump(genres, n = 10))

merged_df$runtime_missing <- is.na(merged_df$runtimeMinutes)

#Run all of the plots at once to view them side by side

ggplot(basics, aes(x = startYear, fill = runtime_missing)) +
  geom_bar(position = "fill") +
  labs(title = "Proportion of missing runtimes by release year",
       y = "Proportion")

ggplot(basics_long, aes(x = genres, fill = runtime_missing)) +
  geom_bar(position = "fill") +
  labs(title = "Proportion of Missing Runtimes by Top 10 Genres",
       x = "Genre",
       y = "Proportion") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

merged_df %>%
  mutate(vote_bin = cut(numVotes,
                        breaks = c(0, 100, 1000, 10000, 100000, Inf),
                        labels = c("0–100", "101–1k", "1k–10k", "10k–100k", "100k+"))) %>%
  ggplot(aes(x = vote_bin, fill = is.na(runtimeMinutes))) +
  geom_bar(position = "fill") +
  labs(title = "Proportion of Missing Runtimes by Vote Category",
       x = "Vote Category",
       y = "Proportion")

ggplot(merged_df, aes(x = averageRating, fill = runtime_missing)) +
  geom_bar(position = "fill") +
  labs(title = "Proportion of missing runtimes by Average Rating",
       y = "Proportion")

merged_df$log10_numVotes <- log10(merged_df$numVotes)

#Statistical test of missing patterns
chisq.test(table(basics$startYear, basics$runtime_missing))
chisq.test(table(basics_long$genres, basics_long$runtime_missing))


```


```{r}
# Merge basics and ratings datasets on the common key "tconst"
merged_df <- merge(basics, ratings, by = "tconst")
# Filter merged dataset for analysis 
merged_df <- merged_df %>%  filter((str_detect(merged_df$genres,"Comedy")) | (str_detect(merged_df$genres,"Action")) |(str_detect(merged_df$genres,"Adventure"))  # Keep movies that belong to at least one of the target genres
                                   ) %>%  filter(runtimeMinutes >=30 # Exclude very short films
                                                 ) %>% filter(numVotes >=50) # Keep only movies with enough votes (reliable ratings)
```





